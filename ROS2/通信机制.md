# 通信机制
节点与节点之间的通信机制
## 1. 话题通信
类似于广播，发布者（Publisher）发布消息，所有订阅者（Subscriber）都可以收到消息。一个发布者可以发布多个话题，而一个订阅者也可以订阅多个话题。

- 发布者（Publisher）和订阅者（Subscriber）模型
### 1. 话题通信模型
- 发布者（Publisher）：负责发布消息到话题。
- 订阅者（Subscriber）：负责从话题接收消息。
### 2. 话题通信模型示例
- 发布者（Publisher）示例
    - C++ 发布者示例
        - auto publisher = node->create_publisher<msg_type>(topic_name, qos_profile); # 创建发布者对象（消息类型，话题名称，队列长度）
        - publisher->publish(msg); # 发布消息（msg为消息对象），一般在循环中定时发布
    - Python 发布者示例
        - publisher = node.create_publisher(msg_type, topic_name, qos_profile) # 创建发布者对象（消息类型，话题名称，队列长度）
        - publisher.publish(msg) # 发布消息（msg为消息对象），一般在循环中定时发布
- 订阅者（Subscriber）示例
    - C++ 订阅者示例 
        - auto subscription = node->create_subscription<msg_type>(topic_name, qos_profile, callback);
    - Python 订阅者示例
        - subscription = node.create_subscription(msg_type, topic_name, qos_profile, callback) # 创建订阅者对象（消息类型，话题名称，队列长度，回调函数）

### 3. 话题通信命令
- ros2 topic list # 查看当前系统中的所有话题
- ros2 topic echo /topic_name # 查看话题 /topic_name 上的消息
- ros2 topic info /topic_name # 查看话题 /topic_name 的详细信息
- ros2 topic hz /topic_name # 查看话题 /topic_name 的发布频率

## 2. 服务通信
- 客户端（Client）和服务端（Server）模型
- 客户端发送请求，服务器端收到请求后，进行处理并反馈应答消息。
- 一对多通信，客户端类似于个人，服务端类似于网站。可以很多人同时向网站请求信息。

### 服务通信模型示例
- 客户端（client）示例
    - C++ 客户端示例
        - auto client = node->create_client<service_type>(service_name); # 创建客户端对象
        - auto request = std::make_shared<service_type::Request>(); # 创建客户端数据
        - // 填充 request 数据
        - auto result_future = client->async_send_request(request); # 发送请求数据，这里不用回调函数机制，因为想什么请求就什么时候请求。
        - // 通过 result_future.get() 或回调方式获取应答

    - Python 客户端示例
        - client = node.create_client(service_type, service_name)
        - request = service_type.Request()
        - # 填充 request 数据
        - future = client.call_async(request)
        - # 通过回调或检查 future.done() 获取应答
- 服务端（service）示例
    - C++ 服务端（Server）示例
        - auto server = node->create_service<service_type>(
            service_name,
            [](const std::shared_ptr<rmw_request_id_t> request_header,
               const std::shared_ptr<service_type::Request> request,
               std::shared_ptr<service_type::Response> response)
            {
                // 处理请求并填充 response
            }
        ); # 创建服务端对象并定义回调，需要用到回调函数，因为不知道请求数据什么时间出现。

    - Python 服务端（Server）示例
        - def callback(request, response):
            # 处理请求并填充 response
            return response
        - server = node.create_service(service_type, service_name, callback) # 创建服务端对象

 
## 3. 动作通信
- 客户端（Client）和服务端（Server）模型